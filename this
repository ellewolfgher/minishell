
int	ft_minishell_execute(t_data *ms)
{
	t_execute	*command;
	int			control;
	int			og_fds[2];

	control = 1;
	og_fds[0] = -1;
	og_fds[1] = -1;
	ft_signals_ignore();
	while (control)
	{
		command = ft_execute_set_commands(ms);
		control = ft_execute_loop(command, ms, og_fds);
		ft_free_execute(command);
		if (ms->need_to_exit)
			break ;
	}
	while (wait(&ms->exit_code) > 0)
		continue ;
	if (ms->exit_code >= 256)
		ms->exit_code = ms->exit_code >> 8;
	ft_signals_init();
	ft_fds_restore(og_fds);
	ms->state = CLEANSTATE;
	return (0);
}

static void	ft_set_struct(t_data *ms, t_execute *command)
{
	command->receives_from_pipe = ft_searchset_pipe_in(ms);
	command->command = ft_searchset_command(ms, command);
	command->args = ft_searchset_arguments(ms);
	command->red_in = ft_searchset_input(ms);
	command->red_out = ft_searchset_output(ms);
	command->envp = ft_searchset_envvars(ms->env_vars);
	command->sends_to_pipe = ft_searchset_pipe_out(ms);
}

static int	ft_check_errtoken(t_data *ms, t_execute *command)
{
	t_tokens	*aux;

	aux = ms->tokens;
	while (aux)
	{
		if (aux->type == ERRTOKEN)
		{
			command->block_exec = 1;
			command->error_to_print = ft_strdup("Invalid syntax\n");
			return (1);
		}
		aux = aux->next;
	}
	return (0);
}

static int	ft_check_last_token(t_data *ms)
{
	t_tokens	*aux;

	aux = ms->tokens;
	while (aux->next)
		aux = aux->next;
	if (ms->tok_index > aux->index)
		return (1);
	return (0);
}

t_execute	*ft_execute_set_commands(t_data *ms)
{
	t_execute	*command;

	if (ft_check_last_token(ms))
		return (NULL);
	command = ft_calloc(1, sizeof(t_execute));
	if (ft_check_errtoken(ms, command))
		return (command);
	ft_set_struct(ms, command);
	return (command);
}

static int	ft_how_many_args(t_tokens *aux)
{
	t_tokens	*other;
	int			count;

	other = aux;
	count = 0;
	if (other && (other->type == COMTOKEN || other->type == BITOKEN))
	{
		count++;
		other = other->next;
	}
	while (other && other->type == WORDTOKEN)
	{
		count++;
		other = other->next;
	}
	return (count);
}

char	**ft_searchset_arguments(t_data *ms)
{
	t_tokens	*aux;
	char		**matrix;
	int			count;
	int			index;

	count = 0;
	index = 0;
	aux = ft_tokens_iterate(ms);
	while (aux && (aux->type != COMTOKEN && aux->type != BITOKEN))
	{
		aux = aux->next;
		if (aux && aux->type == OPTOKEN)
			return (NULL);
	}
	if (!aux)
		return (NULL);
	count = ft_how_many_args(aux);
	matrix = ft_calloc(count + 1, sizeof(char *));
	while (index < count)
	{
		matrix[index] = ft_strdup(aux->value);
		aux = aux->next;
		index++;
	}
	return (matrix);
}

static char	**ft_cat_paths_to_command(char *command, char **paths)
{
	int		index[3];
	char	*aux;

	index[0] = 0;
	index[1] = 0;
	index[2] = 0;
	while (paths[index[0]])
	{
		aux = ft_calloc(1, sizeof (char) * (ft_strlen(command)
					+ 2 + ft_strlen(paths[index[0]])));
		while (paths[index[0]][index[1]])
		{
			aux[index[1]] = paths[index[0]][index[1]];
			index[1]++;
		}
		aux[index[1]++] = '/';
		while (command[index[2]])
			aux[index[1]++] = command[index[2]++];
		aux[index[1]] = '\0';
		index[1] = 0;
		index[2] = 0;
		free(paths[index[0]]);
		paths[index[0]++] = aux;
	}
	return (paths);
}

static char	*ft_path_from_token(char *value, t_env_vars *environvars)
{
	t_env_vars	*aux;
	char		**allpaths;
	char		*path;

	aux = environvars;
	if (!ft_strncmp(value, ".", 1))
		return (ft_strdup(value));
	if (value[0] == '\0')
		return (ft_strdup(value));
	while (aux && ft_strncmp(aux->content, "PATH=", 5))
		aux = aux->next;
	if (!aux)
		return (NULL);
	allpaths = ft_split(aux->content + 5, ':');
	allpaths = ft_cat_paths_to_command(value, allpaths);
	path = ft_test_access(allpaths);
	ft_free_matrix((void ***)&allpaths);
	return (path);
}

char	*ft_searchset_command(t_data *ms, t_execute *this)
{
	t_tokens	*aux;
	char		*path;

	path = NULL;
	aux = ft_tokens_iterate(ms);
	while (aux && (aux->type != COMTOKEN && aux->type != BITOKEN))
		aux = aux->next;
	if (!aux)
		return (NULL);
	if (aux->type == BITOKEN)
	{
		this->is_builtin = 1;
		return (ft_strdup(aux->value));
	}
	if (aux->type == COMTOKEN)
		path = ft_path_from_token(aux->value, ms->env_vars);
	if (!path)
	{
		this->error_to_print = ft_strjoin(aux->value, ": command not found\n");
		return (ft_strdup(aux->value));
	}
	return (path);
}

static int	ft_count_env_vars(t_env_vars *head)
{
	t_env_vars	*aux;
	int			count;

	aux = head;
	count = 0;
	while (aux)
	{
		aux = aux->next;
		count++;
	}
	return (count);
}

static void	ft_fill_envvars(char **ret, t_env_vars *head, int top)
{
	int	index;

	index = 0;
	while (head && index < top - 1)
	{
		ret[index] = ft_strdup(head->content);
		index++;
		head = head->next;
	}
}

char	**ft_searchset_envvars(t_env_vars *head)
{
	t_env_vars	*aux;
	int			count;
	char		**list;

	aux = head;
	count = ft_count_env_vars(aux);
	if (!count)
		return (0);
	list = ft_calloc(count, sizeof(*list));
	ft_fill_envvars(list, aux, count);
	return (list);
}

static int	ft_count_inputs(t_tokens *aux)
{
	t_tokens	*other;
	int			count;

	count = 0;
	other = aux;
	if (other && other->type == OPTOKEN)
		other = other->next;
	while (other && other->type != OPTOKEN)
	{
		if (other->type == REDTOKEN)
		{
			if (!ft_strcmp("<", other->value))
				count++;
			else if (!ft_strcmp("<<", other->value))
				count++;
		}
		other = other->next;
	}
	return (count);
}

static t_tokens	*ft_last_path(t_tokens *tokens)
{
	t_tokens	*last;
	t_tokens	*current;

	last = tokens;
	current = tokens;
	while (current)
	{
		if (current->next && ft_is_file(current->next->value))
			last = current->next;
		current = current->next;
	}
	return (last);
}

static void	ft_fill_inlist(t_redirect *this, t_tokens *tokens)
{
	t_tokens	*last;

	if (tokens && tokens->type == OPTOKEN)
		tokens = tokens->next;
	while (tokens && this && tokens->type != OPTOKEN)
	{
		if (tokens->type == REDTOKEN)
		{
			if (!ft_strcmp("<", tokens->value))
			{
				last = ft_last_path(tokens->next);
				this->type = INFILE;
				this->target = ft_strdup(last->value);
				this = this->next;
			}
			if (!ft_strcmp("<<", tokens->value))
			{
				this->type = HEREDOC;
				this->target = ft_strdup(tokens->next->value);
				this = this->next;
			}
		}
		tokens = tokens->next;
	}
}

t_redirect	*ft_searchset_input(t_data *ms)
{
	t_tokens		*aux;
	t_redirect		*self;
	int				count;

	aux = ft_tokens_iterate(ms);
	count = ft_count_inputs(aux);
	self = ft_redirect_list(count);
	if (self)
		ft_fill_inlist(self, aux);
	return (self);
}

static int	ft_count_outputs(t_tokens *aux)
{
	t_tokens	*other;
	int			count;

	count = 0;
	other = aux;
	if (other && other->type == OPTOKEN)
		other = other->next;
	while (other && other->type != OPTOKEN)
	{
		if (other->type == REDTOKEN)
		{
			if (!ft_strcmp(">", other->value))
				count++;
			else if (!ft_strcmp(">>", other->value))
				count++;
		}
		other = other->next;
	}
	return (count);
}

static void	ft_fill_outlist(t_redirect *this, t_tokens *tokens)
{
	if (tokens && tokens->type == OPTOKEN)
		tokens = tokens->next;
	while (tokens && this && tokens->type != OPTOKEN)
	{
		if (tokens->type == REDTOKEN)
		{
			if (!ft_strcmp(">", tokens->value))
			{
				this->type = OVERWRITE;
				this->target = ft_strdup(tokens->next->value);
				this = this->next;
			}
			if (!ft_strcmp(">>", tokens->value))
			{
				this->type = APPEND;
				this->target = ft_strdup(tokens->next->value);
				this = this->next;
			}
		}
		tokens = tokens->next;
	}
}

t_redirect	*ft_searchset_output(t_data *ms)
{
	t_tokens		*aux;
	t_redirect		*self;
	int				count;

	aux = ft_tokens_iterate(ms);
	count = ft_count_outputs(aux);
	self = ft_redirect_list(count);
	if (self)
		ft_fill_outlist(self, aux);
	return (self);
}

int	ft_searchset_pipe_in(t_data *ms)
{
	t_tokens	*aux;

	aux = ft_tokens_iterate(ms);
	if (aux && aux->type == OPTOKEN)
		return (1);
	return (0);
}

int	ft_searchset_pipe_out(t_data *ms)
{
	t_tokens	*aux;

	aux = ft_tokens_iterate(ms);
	if (aux && aux->type == OPTOKEN)
	{
		aux = aux->next;
		ms->tok_index++;
	}
	while (aux)
	{
		if (aux->type == OPTOKEN)
			return (1);
		ms->tok_index++;
		aux = aux->next;
	}
	return (0);
}
int	ft_execute_loop(t_execute *command, t_data *ms, int og_fds[2])
{
	if (!command)
		return (0);
	if (command->block_exec)
	{
		write (2, command->error_to_print, ft_strlen(command->error_to_print));
		return (0);
	}
	ft_execute_output_create(command);
	if (!command->receives_from_pipe && !command->sends_to_pipe)
	{
		ft_execute_only_one(command, ms, og_fds);
		return (0);
	}
	else if (!ms->need_to_exit)
		return (ft_execute_multiple(command, ms, og_fds));
	return (1);
}
void	ft_execute_output_create(t_execute *command)
{
	t_redirect	*aux;

	aux = command->red_out;
	while (aux)
	{
		open(aux->target, O_CREAT | O_RDONLY, 0777);
		aux = aux->next;
	}
}
static int	ft_execute_only_one(t_execute *command, t_data *ms, int og_fds[2])
{
	if (ms->need_to_exit)
		return (ms->need_to_exit);
	if (command->is_builtin)
		ft_execute_builtin(command, ms, og_fds);
	else
		ms->exit_code = ft_execute_command(command, ms, og_fds);
	return (0);
}
int	ft_execute_builtin(t_execute *command, t_data *ms, int og_fds[2])
{
	if (!command->sends_to_pipe && !command->receives_from_pipe)
	{
		if (ft_execute_redirects(command, og_fds, ms))
			return (ft_fds_restore(og_fds));
	}
	if (!ft_strcmp(command->command, "cd"))
		ft_command_cd(ms, command);
	if (!ft_strcmp(command->command, "echo"))
		ft_command_echo(ms);
	if (!ft_strcmp(command->command, "env"))
		ft_command_env(ms->env_vars);
	if (!ft_strcmp(command->command, "exit"))
		ft_command_exit(ms, command);
	if (!ft_strcmp(command->command, "export"))
		ft_command_export(ms, command);
	if (!ft_strcmp(command->command, "pwd"))
		ft_command_pwd();
	if (!ft_strcmp(command->command, "unset"))
		ft_command_unset(ms);
	return (0);
}
void	ft_command_echo(t_data *ms)
{
	int			newline;
	t_tokens	*tokens;

	newline = 0;
	tokens = ms->tokens->next;
	if (tokens && tokens->type == WORDTOKEN && strcmp(tokens->value, "-n") == 0)
	{
		newline = 1;
		tokens = tokens->next;
	}
	while (tokens)
	{
		if (tokens->type == WORDTOKEN)
		{
			printf("%s", tokens->value);
			if (tokens->next)
				printf(" ");
		}
		tokens = tokens->next;
	}
	if (!newline)
		printf("\n");
}
int	ft_execute_command(t_execute *command, t_data *ms, int og_fds[2])
{
	int	pid;

	(void)og_fds;
	pid = ft_execute_fork();
	if (!pid)
	{
		ms->exit_code = 0;
		if (!ft_execute_get_error(command->command, ms))
		{
			ft_signals_default();
			if (ft_execute_redirects(command, og_fds, ms))
			{
				ms->need_to_exit = -1;
				return (ft_fds_restore(og_fds));
			}
			execve(command->command, command->args, command->envp);
		}
		else
			ms->need_to_exit = -1;
		return (ms->exit_code);
	}
	return (ms->exit_code);
}
int	ft_execute_get_error(char *path, t_data *ms)
{
	struct stat	sb;

	if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode))
	{
		ms->exit_code = 126;
	}
	if (!path)
		ms->exit_code = 1;
	else if (access(path, X_OK))
	{
		ms->exit_code = 127;
		ft_putstr_fd(path, STDERR_FILENO);
		ft_putstr_fd(": command not found\n", STDERR_FILENO);
	}
	return (ms->exit_code);
}
int	ft_execute_multiple(t_execute *command, t_data *ms, int og_fds[2])
{
	int	control;

	if (og_fds[0] == NO_REDIRECT)
		og_fds[0] = dup(STDIN_FILENO);
	if (og_fds[1] == NO_REDIRECT)
		og_fds[1] = dup(STDOUT_FILENO);
	ft_pipe_swap(ms);
	control = command->sends_to_pipe;
	if (ms->need_to_exit)
		return (ms->need_to_exit);
	if (command->is_builtin)
		ms->exit_code = ft_execute_piped_builtin(command, ms, og_fds);
	else
		ms->exit_code = ft_multiple_executions(command, ms, og_fds);
	return (control);
}
static int	ft_pipe_swap(t_data *ms)
{
	static int	init;

	if (!init)
	{
		pipe(ms->pipe_out);
		init++;
	}
	ms->pipe_in[0] = ms->pipe_out[0];
	ms->pipe_in[1] = ms->pipe_out[1];
	pipe(ms->pipe_out);
	return (0);
}
static int	ft_multiple_executions(t_execute *command,
				t_data *ms, int og_fds[2])
{
	int	pid;

	(void)og_fds;
	pid = ft_execute_fork();
	if (!pid)
	{
		ms->exit_code = 0;
		if (!ft_execute_get_error(command->command, ms))
		{
			ft_signals_default();
			ft_handle_pipes(ms, command);
			execve(command->command, command->args, command->envp);
		}
		else
			ms->need_to_exit = -1;
		return (ms->exit_code);
	}
	close(ms->pipe_in[0]);
	close(ms->pipe_in[1]);
	return (ms->exit_code);
}
static int	ft_execute_piped_builtin(t_execute *command,
				t_data *ms, int og_fds[2])
{
	int	pid;

	pid = ft_execute_fork();
	if (!pid)
	{
		ft_signals_default();
		ft_handle_pipes(ms, command);
		if (ft_execute_redirects(command, og_fds, ms))
		{
			ms->need_to_exit = -1;
			return (ft_fds_restore(og_fds));
		}
		ms->need_to_exit = -1;
		ft_execute_builtin(command, ms, og_fds);
	}
	return (ms->exit_code);
}
static int	ft_handle_pipes(t_data *ms, t_execute *command)
{
	if (command->receives_from_pipe)
	{
		close(ms->pipe_in[1]);
		dup2(ms->pipe_in[0], STDIN_FILENO);
	}
	if (command->sends_to_pipe)
	{
		close(ms->pipe_out[0]);
		dup2(ms->pipe_out[1], STDOUT_FILENO);
	}
	return (0);
}
